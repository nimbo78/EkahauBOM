#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""PDF exporter using WeasyPrint for professional reports."""

from __future__ import annotations


import html as html_module
import logging
from collections import Counter
from pathlib import Path
from typing import Optional

try:
    from weasyprint import HTML, CSS

    WEASYPRINT_AVAILABLE = True
except ImportError:
    WEASYPRINT_AVAILABLE = False

from .base import BaseExporter
from ..models import ProjectData, AccessPoint, Antenna
from ..analytics import (
    GroupingAnalytics,
    CoverageAnalytics,
    MountingAnalytics,
    RadioAnalytics,
)

logger = logging.getLogger(__name__)


class PDFExporter(BaseExporter):
    """Export project data to PDF report.

    Creates a professional PDF document with:
    - Summary statistics
    - Tables for access points and antennas
    - Grouping statistics (vendor, floor, color, model)
    - Radio and mounting analytics
    - Print-optimized layout

    Requires: WeasyPrint library
    """

    @property
    def format_name(self) -> str:
        """Human-readable name of the export format."""
        return "PDF"

    def export(self, project_data: ProjectData) -> list[Path]:
        """Export project data to PDF file.

        Args:
            project_data: Processed project data to export

        Returns:
            List containing path to the created PDF file

        Raises:
            ImportError: If WeasyPrint is not installed
        """
        if not WEASYPRINT_AVAILABLE:
            raise ImportError(
                "WeasyPrint is required for PDF export. "
                "Install it with: pip install WeasyPrint>=60.0"
            )

        output_file = self._get_output_filename(project_data.project_name, "report.pdf")

        # Generate HTML content optimized for PDF
        html_content = self._generate_pdf_html(project_data)

        # Convert HTML to PDF
        logger.info(f"Converting HTML to PDF: {output_file}")
        HTML(string=html_content).write_pdf(output_file)

        files = [output_file]
        self.log_export_success(files)
        return files

    def _generate_pdf_html(self, project_data: ProjectData) -> str:
        """Generate HTML document optimized for PDF conversion.

        Args:
            project_data: Project data to export

        Returns:
            Complete HTML document as string
        """
        # Calculate statistics
        total_aps = len(project_data.access_points)

        # Filter and group antennas (only external, dual-band aggregated)
        antenna_counts = self._filter_and_group_antennas(project_data.antennas)
        total_antennas = sum(antenna_counts.values())  # Total external antenna count

        # Count unique values
        unique_vendors = len(set(ap.vendor for ap in project_data.access_points))
        unique_floors = len(set(ap.floor_name for ap in project_data.access_points))
        unique_colors = len(
            set(ap.color for ap in project_data.access_points if ap.color)
        )

        # Generate sections
        summary_html = self._generate_summary(
            project_data.project_name,
            total_aps,
            total_antennas,
            unique_vendors,
            unique_floors,
            unique_colors,
            project_data.metadata,
        )

        grouping_html = self._generate_grouping_section(project_data.access_points)
        analytics_html = self._generate_analytics_section(
            project_data.access_points, project_data.radios
        )
        aps_table_html = self._generate_aps_table(project_data.access_points)
        detailed_aps_table_html = self._generate_detailed_aps_table(
            project_data.access_points
        )
        antennas_table_html = self._generate_antennas_table_from_counts(antenna_counts)

        # Assemble complete HTML document
        html_doc = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{html_module.escape(project_data.project_name)} - Ekahau BOM Report</title>
    {self._get_pdf_styles()}
</head>
<body>
    <div class="container">
        <header>
            <h1>Ekahau BOM Report</h1>
            <h2>{html_module.escape(project_data.project_name)}</h2>
        </header>

        {summary_html}
        {grouping_html}
        {analytics_html}
        {aps_table_html}
        {detailed_aps_table_html}
        {antennas_table_html}

        <footer>
            <p>Generated by EkahauBOM</p>
        </footer>
    </div>
</body>
</html>"""

        return html_doc

    def _get_pdf_styles(self) -> str:
        """Get CSS styles optimized for PDF printing."""
        return """<style>
    @page {
        size: A4;
        margin: 2cm;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: 'Arial', 'Helvetica', sans-serif;
        font-size: 10pt;
        line-height: 1.4;
        color: #333;
    }

    .container {
        max-width: 100%;
    }

    header {
        text-align: center;
        margin-bottom: 2em;
        padding-bottom: 1em;
        border-bottom: 3px solid #2196F3;
    }

    header h1 {
        font-size: 24pt;
        color: #2196F3;
        margin-bottom: 0.3em;
    }

    header h2 {
        font-size: 16pt;
        color: #555;
        font-weight: normal;
    }

    section {
        margin-bottom: 2em;
        page-break-inside: avoid;
    }

    h3 {
        font-size: 14pt;
        color: #2196F3;
        margin-bottom: 0.8em;
        padding-bottom: 0.3em;
        border-bottom: 2px solid #e0e0e0;
    }

    h4 {
        font-size: 12pt;
        color: #555;
        margin-top: 1em;
        margin-bottom: 0.5em;
    }

    /* Summary Statistics */
    .stats-grid {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        margin-bottom: 1.5em;
    }

    .stat-card {
        flex: 1;
        min-width: 100px;
        text-align: center;
        padding: 0.8em;
        margin: 0.3em;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background: #f5f5f5;
    }

    .stat-value {
        font-size: 20pt;
        font-weight: bold;
        color: #2196F3;
        margin-bottom: 0.2em;
    }

    .stat-label {
        font-size: 9pt;
        color: #666;
        text-transform: uppercase;
    }

    /* Tables */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 1.5em;
        font-size: 9pt;
        page-break-inside: auto;
    }

    table thead {
        background: #2196F3;
        color: white;
        font-weight: bold;
    }

    table th {
        padding: 0.6em 0.4em;
        text-align: left;
        font-size: 9pt;
    }

    table td {
        padding: 0.5em 0.4em;
        border-bottom: 1px solid #e0e0e0;
    }

    table tbody tr:nth-child(even) {
        background: #f9f9f9;
    }

    table tr {
        page-break-inside: avoid;
    }

    /* Grouping Section */
    .grouping-stats {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        margin-bottom: 1em;
    }

    .grouping-column {
        flex: 0 0 48%;
        margin-bottom: 1em;
    }

    .grouping-table {
        width: 100%;
        font-size: 9pt;
    }

    .grouping-table th {
        background: #f0f0f0;
        color: #333;
        padding: 0.4em;
        text-align: left;
        border-bottom: 2px solid #ddd;
    }

    .grouping-table td {
        padding: 0.3em 0.4em;
        border-bottom: 1px solid #eee;
    }

    .grouping-table td:last-child {
        text-align: right;
        font-weight: bold;
        color: #2196F3;
    }

    /* Analytics Section */
    .analytics-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
    }

    .analytics-column {
        flex: 0 0 48%;
        margin-bottom: 1em;
    }

    .metric-row {
        display: flex;
        justify-content: space-between;
        padding: 0.3em 0;
        border-bottom: 1px solid #eee;
    }

    .metric-label {
        color: #666;
    }

    .metric-value {
        font-weight: bold;
        color: #2196F3;
    }

    /* Footer */
    footer {
        margin-top: 3em;
        padding-top: 1em;
        border-top: 2px solid #e0e0e0;
        text-align: center;
        font-size: 9pt;
        color: #999;
    }

    /* Utility Classes */
    .text-center {
        text-align: center;
    }

    .text-right {
        text-align: right;
    }

    .mb-1 {
        margin-bottom: 0.5em;
    }

    .mb-2 {
        margin-bottom: 1em;
    }
</style>"""

    def _generate_summary(
        self,
        project_name: str,
        total_aps: int,
        total_antennas: int,
        unique_vendors: int,
        unique_floors: int,
        unique_colors: int,
        metadata=None,
    ) -> str:
        """Generate summary statistics section."""
        # Generate metadata section if available
        metadata_html = ""
        if metadata:
            metadata_items = []
            if metadata.name:
                metadata_items.append(
                    f"<p><strong>Project Name:</strong> {html_module.escape(metadata.name)}</p>"
                )
            if metadata.customer:
                metadata_items.append(
                    f"<p><strong>Customer:</strong> {html_module.escape(metadata.customer)}</p>"
                )
            if metadata.location:
                metadata_items.append(
                    f"<p><strong>Location:</strong> {html_module.escape(metadata.location)}</p>"
                )
            if metadata.responsible_person:
                metadata_items.append(
                    f"<p><strong>Responsible Person:</strong> {html_module.escape(metadata.responsible_person)}</p>"
                )
            if metadata.schema_version:
                metadata_items.append(
                    f"<p><strong>Schema Version:</strong> {html_module.escape(metadata.schema_version)}</p>"
                )

            if metadata_items:
                metadata_html = f"""
            <div class="project-metadata" style="margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-left: 4px solid #2196F3;">
                <h4 style="margin-top: 0;">Project Information</h4>
                {''.join(metadata_items)}
            </div>
            """

        return f"""
        <section class="summary">
            <h3>Summary</h3>
            {metadata_html}
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">{total_aps}</div>
                    <div class="stat-label">Access Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{total_antennas}</div>
                    <div class="stat-label">Antennas</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{unique_vendors}</div>
                    <div class="stat-label">Vendors</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{unique_floors}</div>
                    <div class="stat-label">Floors</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{unique_colors}</div>
                    <div class="stat-label">Colors</div>
                </div>
            </div>
        </section>
        """

    def _generate_grouping_section(self, access_points: list[AccessPoint]) -> str:
        """Generate grouping statistics section."""
        # Group by different dimensions
        by_vendor = GroupingAnalytics.group_by_vendor(access_points)
        by_floor = GroupingAnalytics.group_by_floor(access_points)
        by_color = GroupingAnalytics.group_by_color(access_points)
        by_model = GroupingAnalytics.group_by_model(access_points)

        html = '<section class="grouping"><h3>Distribution Statistics</h3><div class="grouping-stats">'

        # Vendor grouping
        html += self._generate_grouping_table("By Vendor", by_vendor)

        # Floor grouping
        html += self._generate_grouping_table("By Floor", by_floor)

        html += '</div><div class="grouping-stats">'

        # Color grouping
        html += self._generate_grouping_table("By Color", by_color)

        # Model grouping
        html += self._generate_grouping_table("By Model", by_model)

        html += "</div></section>"

        return html

    def _generate_grouping_table(self, title: str, data: dict) -> str:
        """Generate a grouping table."""
        if not data:
            return ""

        total = sum(data.values())

        html = f'<div class="grouping-column"><h4>{html_module.escape(title)}</h4>'
        html += '<table class="grouping-table"><thead><tr><th>Name</th><th>Count</th><th>%</th></tr></thead><tbody>'

        for name, count in sorted(data.items(), key=lambda x: x[1], reverse=True):
            percentage = (count / total * 100) if total > 0 else 0
            html += f"<tr><td>{html_module.escape(str(name))}</td><td>{count}</td><td>{percentage:.1f}%</td></tr>"

        html += "</tbody></table></div>"
        return html

    def _generate_analytics_section(
        self, access_points: list[AccessPoint], radios: list
    ) -> str:
        """Generate analytics section with mounting and radio stats."""
        html = '<section class="analytics"><h3>Analytics</h3>'

        # Mounting analytics
        mounting_analytics = MountingAnalytics.calculate_mounting_metrics(access_points)
        if (
            mounting_analytics
            and mounting_analytics.avg_height is not None
            and mounting_analytics.avg_height > 0
        ):
            html += '<div class="analytics-grid"><div class="analytics-column">'
            html += "<h4>Mounting Statistics</h4>"
            html += f'<div class="metric-row"><span class="metric-label">Average Height:</span><span class="metric-value">{mounting_analytics.avg_height:.2f} m</span></div>'
            html += f'<div class="metric-row"><span class="metric-label">Min Height:</span><span class="metric-value">{mounting_analytics.min_height:.2f} m</span></div>'
            html += f'<div class="metric-row"><span class="metric-label">Max Height:</span><span class="metric-value">{mounting_analytics.max_height:.2f} m</span></div>'
            if mounting_analytics.avg_azimuth:
                html += f'<div class="metric-row"><span class="metric-label">Average Azimuth:</span><span class="metric-value">{mounting_analytics.avg_azimuth:.1f}째</span></div>'
            if mounting_analytics.avg_tilt:
                html += f'<div class="metric-row"><span class="metric-label">Average Tilt:</span><span class="metric-value">{mounting_analytics.avg_tilt:.1f}째</span></div>'
            html += "</div>"

        # Radio analytics
        if radios:
            by_band = RadioAnalytics.group_by_frequency_band(radios)
            by_standard = RadioAnalytics.group_by_wifi_standard(radios)

            html += '<div class="analytics-column">'
            html += "<h4>Radio Configuration</h4>"

            if by_band:
                total_radios = sum(by_band.values())
                for band, count in by_band.items():
                    pct = (count / total_radios * 100) if total_radios > 0 else 0
                    html += f'<div class="metric-row"><span class="metric-label">{html_module.escape(band)}:</span><span class="metric-value">{count} ({pct:.1f}%)</span></div>'

            if by_standard:
                html += '<h4 style="margin-top: 1em;">Wi-Fi Standards</h4>'
                total_radios = sum(by_standard.values())
                for std, count in sorted(
                    by_standard.items(), key=lambda x: x[1], reverse=True
                )[:5]:
                    pct = (count / total_radios * 100) if total_radios > 0 else 0
                    html += f'<div class="metric-row"><span class="metric-label">{html_module.escape(std)}:</span><span class="metric-value">{count} ({pct:.1f}%)</span></div>'

            html += "</div>"

        html += "</div></section>"
        return html

    def _generate_aps_table(self, access_points: list[AccessPoint]) -> str:
        """Generate aggregated access points table."""
        # Group by vendor, model, floor, color
        aggregated = {}
        for ap in access_points:
            key = (ap.vendor, ap.model, ap.floor_name, ap.color or "N/A")
            aggregated[key] = aggregated.get(key, 0) + 1

        html = '<section class="access-points"><h3>Access Points</h3>'
        html += "<table><thead><tr><th>Vendor</th><th>Model</th><th>Floor</th><th>Color</th><th>Quantity</th></tr></thead><tbody>"

        for (vendor, model, floor, color), count in sorted(aggregated.items()):
            html += f"<tr><td>{html_module.escape(vendor)}</td><td>{html_module.escape(model)}</td><td>{html_module.escape(floor)}</td><td>{html_module.escape(color)}</td><td>{count}</td></tr>"

        html += "</tbody></table></section>"
        return html

    def _generate_detailed_aps_table(self, access_points: list[AccessPoint]) -> str:
        """Generate detailed access points installation table."""
        if not access_points:
            return ""

        html = '<section class="ap-details"><h3>Access Points Installation Details</h3>'
        html += "<table><thead><tr><th>AP Name</th><th>Vendor</th><th>Model</th><th>Floor</th><th>X (m)</th><th>Y (m)</th><th>Height (m)</th><th>Azimuth (째)</th><th>Tilt (째)</th></tr></thead><tbody>"

        for ap in access_points:
            name = ap.name if hasattr(ap, "name") and ap.name else "N/A"
            loc_x = (
                f"{ap.location_x:.2f}"
                if hasattr(ap, "location_x") and ap.location_x is not None
                else "N/A"
            )
            loc_y = (
                f"{ap.location_y:.2f}"
                if hasattr(ap, "location_y") and ap.location_y is not None
                else "N/A"
            )
            height = (
                f"{ap.mounting_height:.2f}"
                if hasattr(ap, "mounting_height") and ap.mounting_height is not None
                else "N/A"
            )
            azimuth = (
                f"{ap.azimuth:.1f}"
                if hasattr(ap, "azimuth") and ap.azimuth is not None
                else "N/A"
            )
            tilt = (
                f"{ap.tilt:.1f}"
                if hasattr(ap, "tilt") and ap.tilt is not None
                else "N/A"
            )

            html += f'<tr><td>{html_module.escape(name)}</td><td>{html_module.escape(ap.vendor)}</td><td>{html_module.escape(ap.model)}</td><td>{html_module.escape(ap.floor_name)}</td><td class="text-right">{loc_x}</td><td class="text-right">{loc_y}</td><td class="text-right">{height}</td><td class="text-right">{azimuth}</td><td class="text-right">{tilt}</td></tr>'

        html += "</tbody></table></section>"
        return html

    def _generate_antennas_table(self, antennas: list[Antenna]) -> str:
        """Generate antennas table."""
        if not antennas:
            return ""

        # Aggregate by name (model)
        antenna_counts = Counter(antenna.name for antenna in antennas)

        html = '<section class="antennas"><h3>Antennas</h3>'
        html += "<table><thead><tr><th>Model</th><th>Quantity</th></tr></thead><tbody>"

        for name, count in sorted(antenna_counts.items()):
            html += f"<tr><td>{html_module.escape(name)}</td><td>{count}</td></tr>"

        html += "</tbody></table></section>"
        return html
